# Memory Management

## Background

---

### Memory Space Separation

---

- Each process has a separate memory space.
  - protect the processes from each other
  - fundamental to having multiple processes loaded in memory for concurrent execution
- Range of legal addresses 
  - the process may access and can access only these legal addresses
- **Base register** (smallest legal physical memory address) and **limit register** (specifies the size of the range) determine the range
  - can be loaded only by the OS using a privileged instruction executed only in kernel mode

- CPU hardware compare every address generated in user with the registers to achieve protection
- Illegal memory access (OS memory / other users' memory)
  - will be trapped by OS => fatal error


---

### Addresses Binding

---

- Program must be brought into memory and placed within a process.
  - if resides on a disk as a bin. exec. file.
- Program can reside in any part of the physical memory.
- **Input queue** contains 
  - the processes on the disk that are waiting to be brought into memory for exec.
- A user program goes through several steps before exec.
- Addressees represented in different ways
  - in source code, symbolic address (variable `count`)
  - in compile time, symbolic => relocatable addresses (14 bytes from the beginning of this module)
  - in load time, relocatable => absolute address (74014)
- **Binding** is mapping from one address space to another
- **Compile time**,
  - if knowing where the process will reside in memory,
  - absolute code can be generated 
  - if location changes, recompile

- **Load time**
  - if  location of the process in memory is unknown,
  - compiler must generate relocatable code
  - final binding is delayed until load time

- **Exec. time**
  - if the process can be moved during its exec. from one memory segment to another
  - binding must be delay until run time


---

### Logical and Physical Address Space

---

- **Logical / virtual** - generated by the CPU
- **Physical** - seen by the memory unit / one loaded into the memory-address reg. of the memory
- **Logical address space** - set of all logical addresses generated by a program
- **Physical address space** - set of all physical addresses -> its logical addresses
- Compile and load time address-binding generate identical logical and physical addresses
- Two types of address are differ in exec. time
- Runtime mapping from virtual to physical is done by MMU, memory management unit.
- Caution and Example (Page 356)

---

#### Simple Mapping Scheme

---

- The base register : **relocation register**
- The **value** in the relocation register is added to 
  - every address generated by a user process 
  - at the time the address is sent to memory
- For example, if the base is at 14000, 
  - attempt by the user to address location 0 => relocated to location 14000
  - an access to location 346 => relocated to location 14346

---

### Dynamic Loading

---

- A routine is not loaded until it's called.
- All routines are kept on disk in a **relocatable load format**.
- Detailed step (Page 357)

---

### Dynamic Linking

---

- **Dynamically linked libraries** are system libraries that are linked to user programs when the programs are run.
  - example : language subroutine libraries
  - avoid wastes both disk space and main memory
- Linking is postponed until execution time.
- **stub usage** (Page 357)
- **Benefit of dynamic linking** (Page 358)

---

## Swapping

---

- A process can be **swapped** temporarily out of memory to a **backing store**
  - then brought back into memory for continued execution.
- **Swapping** makes it possible for the **total** physical address space of all processes to **exceed** the real physical memory of the memory.

---

### Standard Swapping

---

- Involves moving processes between main memory and a backing store.
- The system maintains a **ready queue**
  - consists of all processes whose memory images are on the backing store / in memory and are **ready to run**.
- Whenever CPU scheduler decides to execute a process, it calls the **dispatcher**.
- The **dispatcher** checks to see whether the next process in the queue is **in the memory**.
- If it's not, and if there is no **free memory region**,
  - dispatcher **swaps out** a process currently in memory and swaps in the desired process.
  - then, reloads register and transfer control to the selected process.

---

#### Swapping Time

---

- Context-switch time in a swapping system is high due to **transfer time of the disk**.
- The **total transfer time** is directly **proportional** to the **amount** of memory swapped.
- It would be useful to know **exactly** how much memory a user process **is** using.
  - need to **swap only what is actually used**, reducing swap time
- The user must keep the system **informed** of any **changes** in memory requirements
  - request_memory() and release_memory() if using dynamic memory
- The major reason of why standard swapping is not used in modern OS instead of using 
  - modified forms of swapping work in conjunction with virtual memory.


---

#### Swapping Constraints

---

- A process must be **completely idle**.
- A process with any pending I/O operations.
- A I/O operation can asynchronously access the user memory for I/O buffers when a process needs to be swapped out
  - cannot be swapped in this case
- I/O operation can be queued because the device is busy
  - I/O operation might attempt to use memory that belongs to process that newly swapped in instead of the correct one.

---

## Segmentation

---

- Main characteristic : 
  - permits the physical address space of a process to be non-contiguous


---

### Basic Method

---

- Page 364 - Page 365
- Motivation of segmentation : programmer's view
- Segment information : `<segment-number, offset>`

---

### Segmentation Hardware

---

- Page 365 - Page 366
- **Segment table** : an array of base-limit register pairs 
  - each entry - `<segment base, segment limit>`
- Procedure of converting logical address of a segment to physical address in memory

---

## Paging

---

- Have the same characteristic as **segmentation** but provide solutions to fragmentations

---

### Basic Method

---

- Page 367
- Breaking physical memory into fixed-sized blocks, **frames**
- Breaking logical memory into blocks (**frames**) of the same size called, **pages**.
- Procedure when a process is in execution (Page 367, Page 371)

---

#### Pages and Page Table

---

- Page 368
- every address generated by the CPU is divided into two parts
  - **page number (p)**
    - index to a page table
  - **page offset (d)**
- **Page table**
  - base address of each page in physical memory
  - work with **page offset**

---

#### Page Size

---

- Page 369
- If the size of the logical address space is $2^m$, and a page size is $2^n$ bytes,
- then the high-order $m-n$ bits of a logical address => **page number**
- and $n$ low-order bits designate the => **page offset**
- Example : page 370

---

#### Internal Fragmentation

---

- Frames are allocated as units.
- Memory requirements of a process do not happen to coincide with page boundaries,
  - the last frame allocated may not be completely full.
- Example : page 370
- Solution toward internal fragmentation and trade-off

---

### Hardware Support

---

- Page 372
- Simple implementation of page table : a set of dedicated **registers**
- **PTBR** implementation for large table
  - issues of access time, slow down by a factor of 2
- **TLB** to resolve issues of **PTBR** (Page 373)
  - Detail steps of retrieving items
  - Performance calculation (Page 374)
- Usage of **TLB** with page tables (Page 373) (similar to CPU L1, L2, L3 caching)

---

### Shared Pages

---

- **Sharing** common code (Page 376)

---

### Protection (Page 375)

---

- Protection is accomplished by **protection bits** associated with each frame
- **Valid-invalid** bit
  - *valid*, 
    - the associated page is in the process's logical address space 
    - and is thus a legal (or valid) page.

  - *invalid*,
    - the page is not in the process's logical address space


---